/**
 * @author Lauren Ward
 *
 * Authenticates users based on the acmToken generated by the CORENA ACM application
 * 
 */

const Jwt = require("jsonwebtoken");
const Util = require("util");
const Fetch = require('node-fetch');

const KibanaToken = require('./kibanatoken');
const Config = require("../config");
const Logger = require("../logger");

const urlVerifyToken = getUrlVerifyToken();
const urlUrlVerifyPermission = getUrlVerifyPermission();

/**
 * Construct ACM URL to verify acmToken
 */
function getUrlVerifyToken() {
  return encodeURI(Config.acmProtocol() + "://" + Config.acmHost() + ":" + Config.acmPort() + "/acmserver/api/auth");
}

function getUrlVerifyPermission() {
  return encodeURI(Config.acmProtocol() + "://" + Config.acmHost() + ":" + Config.acmPort() + "/acmserver/api/permissiontypes/" + Config.acmPermissionType());
}

module.exports = {

  /**
   * Using properties from acmToken, create Kibana token that is used to validate the system.
   * This enables Audit Manager to be less chatty with ACM.
   */
  setKibanaToken: async (request, h) => {

    let authToken = await module.exports.getToken(request);
    let decodeToken = Jwt.decode(authToken);

    return new Promise( (resolve, reject) => {
      let token = KibanaToken.signToken(decodeToken.sub, decodeToken.groups, decodeToken.exp, decodeToken.iat);

      h.state(Config.tokenName(), token, Config.cookie());
      request.state[Config.tokenName()] = token;

      if (request.headers.cookie) {
        request.headers.cookie += Util.format('; %s=%s', Config.tokenName(), token);
      } else {
        request.headers.cookie = Util.format('%s=%s', Config.tokenName(), token);
      }

      resolve();
    });

  },

  /**
   * Test if request contains an acmToken
   *
   * @param request the http request object
   */
  hasToken: async (request) => {
    return new Promise(function(resolve, reject) {
      let tokenExists = false;
      if (request.state[Config.acmTokenName()]) {
        tokenExists = true;
      }
      resolve(tokenExists);
    });
  },

  /**
   * Get the acmToken from the request
   *
   * @param request the http request object
   */
  getToken: async (request) => {
    return new Promise(function(resolve, reject) {
      resolve(request.state[Config.acmTokenName()]);
    });
  },

  /**
   * Verify the acmToken with ACM server
   *
   * @param request the http request object
   */
  verifyToken: async (request) => {
    let acmToken = await module.exports.getToken(request);
    let response = await Fetch(urlVerifyToken, {
      method: "put",
      body: JSON.stringify({ token: acmToken }),
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    });

    if (response.status !== 200) {
      throw new Error(
        Util.format("acmToken was not valid; Returned error '%s'", response.statusText)
      );
    } else {
      return true;
    }
  },

  /**
   * Verify the ACM user jas the correct ACM permission type
   *
   * @param request the http request object
   */
  verifyPermissions: async (request) => {
    let acmToken = await module.exports.getToken(request);
    let response = await Fetch(urlUrlVerifyPermission, {
      method: "get",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: "Bearer " + acmToken
      }
    });

    if (response.status !== 200) {
      throw new Error(
        Util.format("User not configured with required permission type '%s'; Returned error '%s'", 
          Config.acmPermissionType, 
          response.statusText)
      );
    } else {
      return true;
    }
  }
};